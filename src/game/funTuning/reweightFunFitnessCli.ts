import { readFile, writeFile } from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import { createInterface } from 'node:readline/promises'

import {
  FUN_FITNESS_COMPONENT_KEYS,
  DEFAULT_FUN_FITNESS_WEIGHTS,
  computeFunFitnessComponents,
  computeWeightedFunFitnessScore,
  type FunFitnessComponentKey,
  type FunFitnessComponentScores,
  type FunFitnessWeights,
  type FunTuningGeneration,
  type FunTuningReport,
  type TrialRunReport,
  type TrialRepetitionResult,
} from './funTuning'

interface CliArguments {
  inputPath?: string
  outputPath?: string
  weights: FunFitnessWeights
  weightsFile?: string
  collectFeedback: boolean
  feedbackPath?: string
  showHelp: boolean
  verbose: boolean
  promptLimit?: number
}

interface SuiteReportEntry {
  suite: {
    id: string
    label: string | null
  }
  report: FunTuningReport
}

interface TrialFeedbackRecord {
  trialId: string
  trialLabel: string | null
  generation: number | null
  enjoyed: boolean
  weights: Record<FunFitnessComponentKey, number>
  componentAverages: FunFitnessComponentScores
  originalAverageScore: number
  reweightedAverageScore: number
  timestamp: string
  metadata?: Record<string, unknown> | null
}

interface ReweightedTrialSummary {
  trial: TrialRunReport
  generation: number | null
  originalAverage: number
  reweightedAverage: number
  componentAverages: FunFitnessComponentScores
}

interface ReweightedGenerationSummary {
  generation: number
  mutationFactor: number
  trials: ReweightedTrialSummary[]
}

interface ReweightOutput {
  weights: Record<FunFitnessComponentKey, number>
  type: 'trial-run' | 'fun-tuning' | 'suite-collection'
  trial?: ReweightedTrialSummary
  generations?: ReweightedGenerationSummary[]
  suites?: {
    id: string
    label: string | null
    generations: ReweightedGenerationSummary[]
  }[]
  bestTrial?: {
    trialId: string
    trialLabel: string | null
    generation: number | null
    originalAverage: number
    reweightedAverage: number
  }
}

function printUsage(): void {
  console.log(
    `Fun fitness re-weighting CLI\n\n` +
      `Usage: npm run fun-reweight -- --input ./report.json [options]\n\n` +
      `Required flags:\n` +
      `  --input <path>          Path to a JSON file generated by the fun tuning runner.\n\n` +
      `Optional flags:\n` +
      `  --weights balance=1,gap=1,...   Override component weights inline.\n` +
      `  --weights-file <path>           Path to a JSON file containing weight overrides.\n` +
      `  --output <path>                 Write a JSON report with re-weighted scores.\n` +
      `  --collect-feedback              Prompt for thumbs up/down feedback and save it.\n` +
      `  --feedback <path>               Destination for feedback records (default funFitnessFeedback.json).\n` +
      `  --limit <number>                Limit the number of feedback prompts.\n` +
      `  --verbose                       Print additional processing details.\n` +
      `  --help                          Show this help message.\n`,
  )
}

function parseArguments(argv: string[]): CliArguments {
  const args: CliArguments = {
    weights: {},
    collectFeedback: false,
    showHelp: false,
    verbose: false,
  }

  for (let index = 0; index < argv.length; index += 1) {
    const value = argv[index]
    if (!value) continue

    switch (value) {
      case '--help':
        args.showHelp = true
        break
      case '--input':
        args.inputPath = argv[++index]
        break
      case '--output':
        args.outputPath = argv[++index]
        break
      case '--weights':
        args.weights = parseWeightOverrides(argv[++index] ?? '')
        break
      case '--weights-file':
        args.weightsFile = argv[++index]
        break
      case '--collect-feedback':
        args.collectFeedback = true
        break
      case '--feedback':
        args.feedbackPath = argv[++index]
        break
      case '--verbose':
        args.verbose = true
        break
      case '--limit': {
        const limitValue = Number(argv[++index])
        if (!Number.isNaN(limitValue) && limitValue > 0) {
          args.promptLimit = Math.floor(limitValue)
        }
        break
      }
      default:
        break
    }
  }

  return args
}

function parseWeightOverrides(value: string): FunFitnessWeights {
  const overrides: FunFitnessWeights = {}
  if (!value) {
    return overrides
  }

  const pairs = value.split(',')
  for (const pair of pairs) {
    const [rawKey, rawWeight] = pair.split('=')
    if (!rawKey || rawWeight === undefined) {
      continue
    }
    const key = rawKey.trim() as FunFitnessComponentKey
    if (!FUN_FITNESS_COMPONENT_KEYS.includes(key)) {
      continue
    }
    const parsed = Number(rawWeight)
    if (!Number.isNaN(parsed)) {
      overrides[key] = parsed
    }
  }

  return overrides
}

async function loadWeightFile(filePath: string | undefined): Promise<FunFitnessWeights> {
  if (!filePath) {
    return {}
  }

  const resolved = path.resolve(process.cwd(), filePath)
  const content = await readFile(resolved, 'utf8')
  const parsed = JSON.parse(content) as FunFitnessWeights
  const filtered: FunFitnessWeights = {}
  for (const key of FUN_FITNESS_COMPONENT_KEYS) {
    if (typeof parsed[key] === 'number') {
      filtered[key] = parsed[key]
    }
  }
  return filtered
}

function mergeWeights(
  base: Record<FunFitnessComponentKey, number>,
  overrides: FunFitnessWeights,
): Record<FunFitnessComponentKey, number> {
  const merged: Record<FunFitnessComponentKey, number> = { ...base }
  for (const key of FUN_FITNESS_COMPONENT_KEYS) {
    if (typeof overrides[key] === 'number') {
      merged[key] = overrides[key] as number
    }
  }
  return merged
}

function deriveScoreLimit(repetition: TrialRepetitionResult): number {
  const metricScores = Object.values(repetition.metrics.finalScore)
  const metricLimit = metricScores.length ? Math.max(...metricScores) : 0
  if (metricLimit > 0) {
    return metricLimit
  }

  const matchScores = Object.values(repetition.match?.finalScore ?? {})
  return matchScores.length ? Math.max(...matchScores) : 0
}

function average(values: number[]): number {
  if (!values.length) {
    return 0
  }
  return values.reduce((total, value) => total + value, 0) / values.length
}

function averageComponents(
  components: FunFitnessComponentScores[],
): FunFitnessComponentScores {
  const totals: Record<FunFitnessComponentKey, number> = {
    balance: 0,
    gap: 0,
    duration: 0,
    returns: 0,
    shotClock: 0,
    direction: 0,
  }

  for (const component of components) {
    for (const key of FUN_FITNESS_COMPONENT_KEYS) {
      totals[key] += component[key]
    }
  }

  if (!components.length) {
    return totals
  }

  for (const key of FUN_FITNESS_COMPONENT_KEYS) {
    totals[key] /= components.length
  }

  return totals
}

function reweightTrial(
  report: TrialRunReport,
  weights: Record<FunFitnessComponentKey, number>,
  generation: number | null,
): ReweightedTrialSummary {
  const componentList: FunFitnessComponentScores[] = []
  const reweightedScores: number[] = []

  for (const repetition of report.repetitions) {
    const scoreLimit = deriveScoreLimit(repetition)
    const components = computeFunFitnessComponents(repetition.metrics, scoreLimit)
    const reweightedScore = computeWeightedFunFitnessScore(components, weights)
    componentList.push(components)
    reweightedScores.push(reweightedScore)
  }

  return {
    trial: report,
    generation,
    originalAverage: report.summary.averageFunScore,
    reweightedAverage: average(reweightedScores),
    componentAverages: averageComponents(componentList),
  }
}

function reweightGeneration(
  generation: FunTuningGeneration,
  weights: Record<FunFitnessComponentKey, number>,
): ReweightedGenerationSummary {
  const summaries = generation.trialReports.map(report =>
    reweightTrial(report, weights, generation.generation),
  )

  return {
    generation: generation.generation,
    mutationFactor: generation.mutationFactor,
    trials: summaries,
  }
}

function collectAllTrials(
  generations: ReweightedGenerationSummary[],
): ReweightedTrialSummary[] {
  return generations.flatMap(generation => generation.trials)
}

function findBestTrial(
  trials: ReweightedTrialSummary[],
): ReweightedTrialSummary | null {
  if (!trials.length) {
    return null
  }

  let best = trials[0]
  for (const trial of trials) {
    if (trial.reweightedAverage > best.reweightedAverage) {
      best = trial
    }
  }
  return best
}

function formatTrialLabel(summary: ReweightedTrialSummary): string {
  const trialLabel = summary.trial.trial.label ?? summary.trial.trial.id
  if (summary.generation == null) {
    return trialLabel
  }
  return `${trialLabel} (generation ${summary.generation})`
}

function printSummary(
  generations: ReweightedGenerationSummary[],
  weights: Record<FunFitnessComponentKey, number>,
): void {
  console.log('Applied weights:')
  for (const key of FUN_FITNESS_COMPONENT_KEYS) {
    console.log(`  ${key}: ${weights[key].toFixed(2)}`)
  }

  const trials = collectAllTrials(generations)
  if (!trials.length) {
    console.log('No trials found in the provided report.')
    return
  }

  const sorted = [...trials].sort(
    (a, b) => b.reweightedAverage - a.reweightedAverage,
  )

  console.log('\nTop trials by re-weighted average fun score:')
  sorted.slice(0, 10).forEach((trial, index) => {
    const label = formatTrialLabel(trial)
    const delta = trial.reweightedAverage - trial.originalAverage
    console.log(
      `  ${index + 1}. ${label}: ${trial.reweightedAverage.toFixed(3)} ` +
        `(original ${trial.originalAverage.toFixed(3)}, delta ${delta >= 0 ? '+' : ''}${delta.toFixed(3)})`,
    )
  })
}

async function collectFeedback(
  trials: ReweightedTrialSummary[],
  weights: Record<FunFitnessComponentKey, number>,
  destination: string,
  limit?: number,
): Promise<void> {
  if (!trials.length) {
    return
  }

  const resolvedPath = path.resolve(process.cwd(), destination)
  const interfaceRl = createInterface({ input: process.stdin, output: process.stdout })
  const entries: TrialFeedbackRecord[] = []

  let promptsRemaining = typeof limit === 'number' ? limit : trials.length

  for (const trial of trials) {
    if (promptsRemaining <= 0) {
      break
    }

    const label = formatTrialLabel(trial)
    const answer = (await interfaceRl.question(
      `Did players enjoy ${label}? [y]es/[n]o/[s]kip/[q]uit: `,
    ))
      .trim()
      .toLowerCase()

    if (answer === 'q') {
      break
    }

    if (answer === 's' || answer === '') {
      continue
    }

    if (answer !== 'y' && answer !== 'n') {
      console.log('  Input not recognized. Please answer with y, n, s, or q.')
      continue
    }

    const record: TrialFeedbackRecord = {
      trialId: trial.trial.trial.id,
      trialLabel: trial.trial.trial.label ?? null,
      generation: trial.generation,
      enjoyed: answer === 'y',
      weights,
      componentAverages: trial.componentAverages,
      originalAverageScore: trial.originalAverage,
      reweightedAverageScore: trial.reweightedAverage,
      timestamp: new Date().toISOString(),
      metadata: trial.trial.trial.metadata ?? null,
    }

    entries.push(record)
    promptsRemaining -= 1
  }

  interfaceRl.close()

  if (!entries.length) {
    return
  }

  let existing: TrialFeedbackRecord[] = []
  try {
    const existingContent = await readFile(resolvedPath, 'utf8')
    existing = JSON.parse(existingContent) as TrialFeedbackRecord[]
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw error
    }
  }

  const merged = [...existing, ...entries]
  await writeFile(resolvedPath, JSON.stringify(merged, null, 2))
  console.log(`Saved ${entries.length} feedback entr${entries.length === 1 ? 'y' : 'ies'} to ${resolvedPath}.`)
}

async function main(): Promise<void> {
  const args = parseArguments(process.argv.slice(2))

  if (args.showHelp || !args.inputPath) {
    printUsage()
    if (!args.inputPath) {
      process.exitCode = 1
    }
    return
  }

  try {
    const baseWeights = { ...DEFAULT_FUN_FITNESS_WEIGHTS }
    const inlineWeights = args.weights
    const fileWeights = await loadWeightFile(args.weightsFile)
    const mergedWeights = mergeWeights(baseWeights, inlineWeights)
    const weights = mergeWeights(mergedWeights, fileWeights)

    const inputPath = path.resolve(process.cwd(), args.inputPath)
    const reportContent = await readFile(inputPath, 'utf8')
    const parsed = JSON.parse(reportContent)

    const output: ReweightOutput = {
      weights,
      type: 'trial-run',
    }

    if (Array.isArray(parsed.generations)) {
      const report = parsed as FunTuningReport
      const generations = report.generations.map(generation =>
        reweightGeneration(generation, weights),
      )
      const allTrials = collectAllTrials(generations)
      const best = findBestTrial(allTrials)

      output.type = 'fun-tuning'
      output.generations = generations
      if (best) {
        output.bestTrial = {
          trialId: best.trial.trial.id,
          trialLabel: best.trial.trial.label ?? null,
          generation: best.generation,
          originalAverage: best.originalAverage,
          reweightedAverage: best.reweightedAverage,
        }
      }

      printSummary(generations, weights)

      if (args.collectFeedback) {
        const destination = args.feedbackPath ?? 'funFitnessFeedback.json'
        await collectFeedback(allTrials, weights, destination, args.promptLimit)
      }
    } else if (Array.isArray(parsed.suites)) {
      const suites = parsed.suites as SuiteReportEntry[]
      const suiteSummaries = suites.map(entry => {
        const generations = entry.report.generations.map(generation =>
          reweightGeneration(generation, weights),
        )
        return {
          id: entry.suite.id,
          label: entry.suite.label,
          generations,
        }
      })

      output.type = 'suite-collection'
      output.suites = suiteSummaries

      const allTrials = suiteSummaries.flatMap(suite => collectAllTrials(suite.generations))
      const best = findBestTrial(allTrials)
      if (best) {
        output.bestTrial = {
          trialId: best.trial.trial.id,
          trialLabel: best.trial.trial.label ?? null,
          generation: best.generation,
          originalAverage: best.originalAverage,
          reweightedAverage: best.reweightedAverage,
        }
      }

      printSummary(
        suiteSummaries.flatMap(suite => suite.generations),
        weights,
      )

      if (args.collectFeedback) {
        const destination = args.feedbackPath ?? 'funFitnessFeedback.json'
        await collectFeedback(allTrials, weights, destination, args.promptLimit)
      }
    } else if (parsed.repetitions) {
      const report = parsed as TrialRunReport
      const summary = reweightTrial(report, weights, null)
      output.trial = summary

      printSummary(
        [
          {
            generation: summary.generation ?? 0,
            mutationFactor: 0,
            trials: [summary],
          },
        ],
        weights,
      )

      if (args.collectFeedback) {
        const destination = args.feedbackPath ?? 'funFitnessFeedback.json'
        await collectFeedback([summary], weights, destination, args.promptLimit)
      }
    } else {
      throw new Error('Unsupported report format. Expected trial, fun tuning, or suite output.')
    }

    if (args.outputPath) {
      const outputPath = path.resolve(process.cwd(), args.outputPath)
      await writeFile(outputPath, JSON.stringify(output, null, 2))
      if (args.verbose) {
        console.log(`Re-weighted report written to ${outputPath}`)
      }
    }
  } catch (error) {
    console.error('Failed to re-weight fun scores:')
    if (error instanceof Error) {
      console.error(error.message)
    } else {
      console.error(error)
    }
    process.exitCode = 1
  }
}

await main()
